exports.cmdName = () => ({
  name: ['atv'],
  alias: ['black'],
  category: "convert",
  desc: "Convert audios to a black screen video media."
});


exports.getCommand = async (anyaV2, pika, prefix, command) => {
  const util = require('util');
  const exec = util.promisify(require('child_process').exec);
  const fs = require('fs').promises;
  const path = require('path');
  const Config = require("../../config");
  const quoted = pika.quoted ? pika.quoted : pika;
  const mime = (quoted.msg || quoted).mimetype || "";
  if (!/audio/.test(mime)) return pika.reply(`Please tag an audio or send an audio with caption *${prefix + command}*`);
  await pika.react("üé©");
  const proceed = await anyaV2.sendMessage(pika.chat, { text: Config.message.wait }, { quoted: pika });
  const audioBuffer = await quoted.download(getRandomName(4));
  const directory = path.join(__dirname, '../database/trash');
  const vName = getRandomName(5) + ".mp4";

  async function checkFFmpeg() {
    try {
      await exec('ffmpeg -version');
    } catch (error) {
      pika.edit('‚ùå FFmpeg is not installed. Please install FFmpeg.', proceed.key);
      throw error;
    }
  }

  async function getAudio(audioBuffer, directory, vName) {
    try {
      await checkFFmpeg();
      const audioFilePath = path.join(directory, 'temp_audio.mp3');
      const videoPath = path.join(directory, vName);
      await fs.writeFile(audioFilePath, audioBuffer);
      const audioDuration = audioBuffer.length / 44100;
      const cmd = `ffmpeg -f lavfi -i color=c=black:s=720x720:r=30 -t ${audioDuration} -pix_fmt yuv420p -vf "scale=720:720" -an -y black_screen.mp4`;
      await exec(cmd);
      const addAudioCmd = `ffmpeg -i black_screen.mp4 -i ${audioFilePath} -c:v copy -c:a aac -strict experimental -y ${videoPath}`;
      await exec(addAudioCmd);
      await fs.unlink('black_screen.mp4');
      await fs.unlink(audioFilePath);
      const videoData = await fs.readFile(videoPath);
      await anyaV2.sendMessage(pika.chat, {
        video: videoData,
        caption: `_¬© Generated by ${Config.botname}_`
      }, { quoted: pika });
      await pika.edit(Config.message.success, proceed.key);
      await fs.unlink(videoPath);
    } catch (error) {
      pika.edit(`‚ùå ${error.message}`, proceed.key);
      throw error;
    }
  }

  try {
    await getAudio(audioBuffer, directory, vName);
  } catch (error) {
    console.error(error);
  }
};

function getRandomName(length) {
  const alphabet = 'abcdefghijklmnopqrstuvwxyz';
  let name = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * alphabet.length);
    name += alphabet[randomIndex];
  }
  return name;
}
